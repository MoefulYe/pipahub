---
created_at: 2024-07-31
modified_at: 2024-07-31
description: 
aliases: 
tags:
  - 计算机组成原理
title: 数字的表示与运算
---
## 进位计数制与相互转换
### 进位计数法
### 进制转换
- B -> O 或者 B -> H
	三位/四位一组，对应右边一位
- O -> B 或者 H -> B
	左边一位对应右边三/四位
- D -> *
	- 除N取余，逆序输出
	- 乘N取整，正序输出
- * -> D
	按权展开
## 无符号整数的表示
...
## 有符号整数的表示
### 概念
- 真值 表示的值
- 机器数 数据重新用无符号整数解释的值
- 定点小数 约定小数点在符号位后
- 定点整数 约定小数点在最后
### 四种编码方法
#### 原码
#### <span style="text-decoration-line: line-through;">反码</span>
#### 补码
- 同余
- 手动真值机器码互转，即相同数据用补码与无符号的的不同解释（假设数字宽度为$N$）
	- 真值转机器码
		正数不变，负数加上$2^N$，即为机器码
	- 机器码转真值
		把机器码按权展开成十进制，是大于$2^{N}-1$的数字要减去$2^N$
	- 可以利用被转数字与某个特殊数字的和差关系简化运算
- 变形补码 扩大了补码的表示范围，实现溢出判断，**只在ALU中才可能出现，存储格式还是补码**，可以看作宽度宽一位的补码整数，不过范围里有些数字是非法的，是溢出的结果
#### 移码
对应的无符号数减去一个偏置量（通常为$2^{N-1}$ $N$为数字的宽度）即为移码的真值
### 不同宽度的整数的转换
- 小到大
	- 无符号 0扩展
	- 有符号 符号拓展
- 大到小
	- 截断
### 相同宽度的有符号与无符号数的转换
内容不变重新解释
## 定点数运算
### 比较运算
- 无符号数的比较 直接比较即可
- 所有最高位为1的数字小于所有最高位为0的数字，如果最高位相同，还是按照无符号数的比较规则进行比较
### 移位运算
- 逻辑移位 右移出1丢失精度，左移出1溢出
- 算术移位 左移操作与逻辑移位相同，一旦移出了和原标志位相反的位则溢出（如正数移出1，负数移出0），右移移出1丢失精度
- 循环移位
### 加减运算
#### 溢出判断
- 双符号位
- 输入输出符号位不同
- 最高位进位与次高位进位不同
#### 电路实现
#### ALU标志位
- ZF
- OF 仅对有符号运算有意义
- CF 仅对无符号运算有意义
- SF
#### 手算
直接用真值运算，如果没给出真值，则用对应的机器码看作无符号数运算，运算结果是一样的
### 乘法运算
对于补码与无符号数乘法，n位乘以n位得到n位的结果的小乘法运算有相同的位级表现，但是对于n位乘以n位得到2n位的结果的大乘法运算有不同的位级表现
#### 原码乘法
#### 乘法溢出判断
输入两个宽度为$N$的整数，输出宽度为$2N$的结果
- 对于无符号数，高$N$位为0
- 对于**补码表示**的有符号数，**高$N$位的每一位都相同等于低$N$位的符号位**
#### 手算
两个操作数转成真值，两个相乘得到结果的真值再转成机器数
### 除法运算
## 数据的存储和排列
### 字节序
- LSB（the Least Significant Bit）
- MSB（the Most Significant Bit）
- 小端序
	一个跨越了**多个字节**的数据存储时，首个字节是LSB
	现代指令集通常选用的字节序
	一个指向数字的指针天然的是一个指向更低宽度的数字的指针
	鸡蛋的小头
- 大端序
	一个跨越了**多个字节**的数据存储时，首个字节是MSB
	网络字节序
	人类的数字表示法
	鸡蛋的大头
### 内存对齐
- 结构体对齐规则
- 非对齐访问导致访存效率变低，不能保证**访存原子性**，导致不可意料的错误
## 浮点数
### 表示
$$
（-1）^S \cdot R^E \cdot M
$$
- S与M 构成小数原码表示法，S是符号，M是大小
- E通常用移码表示，如果E的宽度为N，那么偏置值一般是$2^{N-1}$
- 规格化 $1/2 \le M \lt 1$，增加表示的有效位数
### IEEE754
![Pasted image 20240731202916](https://r2.pipago360.site/pupahub/2024/09/162d85f38ee15280b980492e1c65c80f.png)

| 类型  | 符号位 | 阶数     | 阶数偏置值    | 尾数  | 规格化浮点数的真值                           |
| --- | --- | ------ | -------- | --- | ----------------------------------- |
| f32 | 1   | **8**  | **127**  | 23  | $(-1)^S \cdot 2^{E-127} \cdot 1.M$  |
| f64 | 1   | **11** | **1023** | 52  | $(-1)^S \cdot 2^{E-1023} \cdot 1.M$ |
- 阶数全0与全1有特殊含义，规格化的浮点数不能用
### 特殊的值

|           | 符号  | 阶数  | 尾数  | 真值                                                     |
| --------- | --- | --- | --- | ------------------------------------------------------ |
| ±0        | 0/1 | 全0  | 全0  |                                                        |
| ±非规格化的浮点数 | 0/1 | 全0  | 非全0 | f32: $(-1)^S 2^{-126} 0.M$,f64: $(-1)^S 2^{-1022} 0.M$ |
| ±inf      | 0/1 | 全1  | 全0  |                                                        |
| nan       | 0/1 | 全1  | 非全0 |                                                        |
#### 特殊值的比较运算
- 不考虑nan，+inf大于一切除了+inf的数字，-inf小于一切除了-inf的数字
- +0 等于 -0
- nan参与的一切比较运算都返回false
### 最大安全整数
`f32::MAX_SAFE_INTEGER === 2 ** 24 - 1`
`f64::MAX_SAFE_INTEGER === 2 ** 53 - 1`
再大的整数就不能精确表示了
### 浮点数真值与机器数的手动转换
## 加减运算
- 对阶
	小阶对大阶，FPU内部浮点暂存器宽度大于存储宽度，所以尾数右移移出的位不要舍掉，一同参与运算
- 加减运算
- 规格化
	- 右规约 至多规约一位，可能要考虑到**上溢出**与**舍入**
	- 左规约 可能移动多位，可能出现**下溢出**
- 舍入
	- 就近舍入
	- 向正无穷舍入
	- 向负无穷舍入
	- 向0舍入
- （指数）溢出
	- 上溢出 抛出异常
	- 下溢出 结果作为0处理